<head><TITLE>MIPSIM Users' Guide</TITLE>

<link rel="stylesheet" type="text/css" href="mipsimweb.css" />

</head>

<html>
<body>
<table width="90%" cellspacing="25" border="0" cellpadding="25" align="center">
  <tbody>

      <tr>
      <TD><h1>MIPSIM</h1><p class="nav">
             <A href="index.html#news">NEWS</a> | 
             <A href="index.html#about">ABOUT MIPSIM</A> | 
	     <A href="index.html#dl">DOWNLOAD</A> | 
	     <A href="Changelog.txt">CHANGELOG</A> | 
	     <A href="guide.html#idx">USERS' GUIDE</A></p>
	     </TD></tr>
	     <tr><TD>
	     <h1><a name="idx"></a>Users' Guide</h1>
      <ol><LI><A href="#ins">INSTALLATION</A></LI>
      <LI><A href="#ums">USING MIPSIM</A><ul><LI><A href="#qst">Quick Start</A></LI>
      <li><A href="#adv">Advanced Options</A></li>
      <li><A href="#dbg">Built-in Debugger</A></li>
      <li><A href="#gdb">GDB Interface</A></li>
      <li><A href="#elt">emips_lite</A></li></ul></ol>
     </TD>
      </tr>
      <tr>
      <td><h2><a name="ins"></a>INSTALLATION</h2>
      <p class="main">To install, untar the source by</p>
         <pre>tar xzvf mipsim.tar.gz</pre>
	 <p class="main">Build the source code by</p>
<pre>cd mipsim
./configure
make
make install</pre>
	 <p class="main">The default installation directory is <i>build/bin</i>.
	 If you want to change this, configure with the flag</p>
<pre>./configure --prefix=PREFIX</pre>
	<p class="main">
	 Note: On Cygwin platforms, you may have to try</p> 
<pre>CONFIG_SHELL=bash ./configure --prefix=PREFIX</pre>
	 <p class="main">To test the installation was successful type</p>
<pre>PREFIX/bin/emips test/wc configure</pre>
<br><a href="#idx">BACK TO INDEX</a>
      </td>
    </tr>
    <tr>
      <td><h2><a name="ums"></a>USING MIPSIM</h2><h2><a name="qst"></a>Quick Start</h2>        
       <p class="main">MIPSIM reads ELF32 little-endian MIPS binaries.  The binaries must be statically linked.  See
	the <A href="http://kegel.com/crosstool/">crosstool page</A> or your compiler documentation
	for more information.</p>
	<h3>Example:</h3> 
      <p class="main">Write a simple c program such as:</p>
      <pre>#include &#060;stdio.h&#062;
      int main()
      {
      	printf("Hello World!");
	return 0;
      }
	</pre>
	<p class="main">Compile the program using the ELF32 MIPS cross-compiler.  Remember to statically link the 
	binary.  The command should be something like:</p>
	<pre>mipsel-linux-gnu-gcc -static -ohello_world hello_world.c </pre>
       <p class="main">To have MIPSIM run your program, simply type</p>
        <pre>./emips hello_world</pre>
	<br><a href="#idx">BACK TO INDEX</a>
	</td>
	</tr>
	<tr><TD><h2><a name="adv"></a>Advanced Options</h2>
	<p class="main">As a default, running the simulator will print out running time information and instruction counts.  
	It also performs permission checks on memory accesses as a default.  The default syntax for running the simulator is:</p>
        <pre>./emips &#060;program name&#062; &#060;program arguments&#062;</pre>
	 <p class="main">If you want MIPSIM to print out various error messages and syscall information, 
	 run it in verbose mode by typing</p>
	 <pre>./emips -v &#060;program name&#062; &#060;program arguments&#062;</pre>
	 <p class="main">You can also set MIPSIM to only run for a certain number of instructions with</p>
	 <pre>./emips -m [number of instructions] &#060;program name&#062; &#060;program arguments&#062;</pre>
	 <br><a href="#idx">BACK TO INDEX</a>
	 </TD></tr>
	 <tr><TD><h2><a name="dbg"></a>Built-in Debugger</h2>
       <p class="main">MIPSIM also has the ability to run in debugging mode for your programs.  To start MIPSIM in 
         debugging mode type:</p>
	 <pre>./emips -d &#060;program name&#062;</pre>
	<p class="main">The following instructions are available at the debugging prompt:</p>
	 <dl>
	 <dt>h</dt><dd>print help message</dd>
         <dt>u [addr]</dt><dd>disassemble 10 instructions from [addr]<br>addr can be either a hex address or 'pc', <br>which will disassemble from the current program counter</dd>
         <dt>d [addr]</dt><dd>dump 256 bytes from memory address [addr]</dd>
         <dt>g [addr]</dt><dd>run until pc = [addr]</dd>
         <dt>t [num]</dt><dd>step [num] instruction(s)</dd>
         <dt>r      </dt><dd>dump gpr and fpr value(s)</dd>
         <dt>rf     </dt><dd>same as 'r' but fpr shown as float</dd>
         <dt>rd     </dt><dd>same as 'r' but fpr shown as double</dd>
         <dt>pc     </dt><dd>dump program counter</dd>
         <dt>hi     </dt><dd>dump HI register</dd>
         <dt>lo     </dt><dd>dump LO register</dd>
         <dt>fcsr   </dt><dd>dump FCSR register</dd>
         <dt>ra     </dt><dd>dump return address register ra(r31)</dd>
         <dt>q</dt><dd>quit</dd>
         </dl>
	 <h3>Example:</h3> 
	 <p class="main">Let's use the program <i>hello_world</i> discussed above.  Although the debugger performs run-time disassembly,
	 it is sometimes useful to create a dump of the assembly code for your program before debugging.  Refer to your compiler 
	 documentation for instructions on creating a dump file.  A common command is something like:</p>
	 <pre>mipsel-linux-gnu-objdump -d hello_world >hello_world.dump</pre>
	 <p>Start the debugger with the command:</p>
	 <pre>./emips -d hello_world</pre>
	 <p class="main">You should now see the debugger prompt.  At the prompt, you can type any of the commands above.  Let's assume 
	 that, from our dump file, we learned that <i>main</i> was at address <i>0x004003e0</i>.  We can use the debugger to run our 
	 program until it reaches <i>main</i> by typing:</p>
	 <pre>&#062;g 4003e0</pre>
	 <p class="main">If we want to see the first 10 instructions in main, we can type:</p>
	 <pre>&#062;u pc</pre>
	 <p class="main">Suppose we want to inspect all memory accesses and we notice that the 5th instruction is</p>
	 <pre>0x004003f0 : 0xafbc0010 sw $gp, 16($sp)</pre>
	 <p class="main">We can step through the first 4 instructions with:</p>
	 <pre>&#062;t 4</pre>
	 <p class="main">To inspect the contents of the registers, we can simply type:</p>
	 <pre>&#062;r</pre>
	 <p class="main">For this we can learn value of the stack pointer, <i>$sp</i>, which is addressed in this memory access.  Assume it
	 is <i>0xbfffbda8</i>.  We can observe the contents of memory at this location by typing:</p>
	 <pre>&#062;d bfffbda8</pre>
	 <p class="main">The command will display 256 bytes of memory, so we can find the contents of memory that our program is accessing.  If we
	 observe that the contents of memory is incorrect, we may want to go back and check previous memory accesses.  We can now terminate 
	 the debugger by typing:</p>
	 <pre>&#062;q</pre>
	 <p class="main">and restart it to trace back to the first memory access.</p>
	 <p class="main">Obviously there are more complicated debugging scenarios than this, but hopefully it will get you started.</p>
	 <br><a href="#idx">BACK TO INDEX</a>
	 </TD></tr>
	 <tr><TD><h2><a name="gdb"></a>GDB Interface</h2>
	<p class="main">Another debugging option is the gdb interface.  This is currently in an experimental phase but may prove useful.  
	 To start the gdb interface, type:</p>
	 <pre>./emips -gdb 127.0.0.1:1234 &#060;program name&#062; &#060;program arguments&#062; &#038;</pre>
	<p class="main">Then start gdb by typing:</p>
	<pre>gdb &#060;program name&#062;
(gdb)target remote 127.0.0.1:1234
(gdb)break main
(gdb)cont</pre>
	<p class="main">Not all of the gdb functionality has been tested, although many gdb commands work.  The interface also works with
	ddd for graphical debugging.</p>
	<br><a href="#idx">BACK TO INDEX</a>
	</TD></tr>
	<tr><TD><h2><a name="elt"></a>emips_lite</h2>
	<p class="main">The emips_lite executable is a stripped-down build of MIPSIM for users who want maximum simulation speed.  The emips executable performs 
	permission checks on memory accesses and counts each instruction.  These features take a large portion of running time, so they have been 
	removed to create emips_lite. Also, emips_lite simulates 4MB memory pages while emips simulates 4KB pages.  The result of larger pages is a 20% speed-up.</p>
	<p class="main">Running emips_lite is the same as running emips, except for the name of the binary.  Just type:</p>
	<pre>./emips_lite &#060;program name&#062; &#060;program arguments&#062;</pre>
	<br><a href="#idx">BACK TO INDEX</a>
      </td>
    </tr>
        <tr>
    <td>
    <p class="main">
          If you have further questions, contact the main authors at wqin@bu.edu or jderrico3@gmail.com. </p>         
      <p class="nav">
             <A href="index.html#news">NEWS</a> | 
             <A href="index.html#about">ABOUT MIPSIM</A> | 
	     <A href="index.html#dl">DOWNLOAD</A> | 
	     <A href="Changelog.txt">CHANGELOG</A> | 
	     <A href="guide.html#idx">USER GUIDE</A></p>
     </TD>
      </tr>
  </tbody>
</table>
</body>
</html>
